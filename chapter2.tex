% From mitthesis package
% Version: 1.07, 2024/09/26
% Documentation: https://ctan.org/pkg/mitthesis


\chapter{Quantum Arithmetic Circuit Design for Double-Factorized Electronic Structure Hamiltonian Simulation}

We now propose and analyze a quantum circuit that approximately simulates $U_A^{(r)}$ from \eqref{eq: expansion}.

\begin{equation}
    U_A^{(r)} = e^{-\frac{i\Delta t}{2}\lambda_r\left(\sum_s \lambda'^{(r)}_s n_s\right)^2} \label{eq: U_A}
\end{equation}

We can substitute the number operator correspondance from \eqref{eq: JWnum} to find the equivalent qubit operator.

\begin{equation}
    U_A^{(r)} = e^{-\frac{i\Delta t}{2}\lambda_r\left(\sum_s \lambda'^{(r)}_s n_s\right)^2} \leftrightarrow e^{-\frac{i\Delta t}{2}\lambda_r\left(\sum_s \lambda'^{(r)}_s \ket{1}\bra{1}_s\right)^2}
\end{equation}

This qubit operator, when acting on a qubit computational basis state $\ket{\vec{x}}$, it simply applies a phase shift that is a function of $\vec{x}$.

\begin{equation}
    e^{-\frac{i\Delta t}{2}\lambda_r\left(\sum_s \lambda'^{(r)}_s \ket{1}\bra{1}_s\right)^2}\ket{\vec{x}} = e^{-\frac{i\Delta t}{2}\lambda_r\left(\sum_s \lambda'^{(r)}_s x_s\right)^2}\ket{\vec{x}}
\end{equation}

We want to find an efficient way to approximately simulate $U_A^{(r)}$. That is, we want to find an operator $\tilde{U}_A^{(r)}$ that applies the specified phase rotation on $\ket{\vec{x}}$ as precisely as possible and with as few gates as possible. As a reminder, the error (and therefore precision) is measured by the operator norm of the difference in the ideal and approximate operators. $\epsilon$ is a parameter that limits the maximum error of this approximation and it affects the cost of $\tilde{U}_A^{(r)}$. A tighter bound requires more gates to achieve that bound.

\begin{equation}
    \epsilon \geq ||U_A^{(r)} - \tilde{U}_A^{(r)}|| = ||e^{-\frac{i\Delta t}{2}\lambda_r\left(\sum_s \lambda'^{(r)}_s n_s\right)^2} - \tilde{U}_A^{(r)}|| \label{eq: error}
\end{equation}

\eqref{eq: expansion} presented a method that simulated $U_A^{(r)}$ exactly (no error) but it required $O(n^2)$ gates. We now present a $\tilde{U}_A^{(r)}$ that requires $O(n\log_2(\frac{n}{\epsilon}) + \log_2(\frac{1}{\epsilon})^2)$ gates. The idea is to coherently calculate the phase of the phase rotation on a separate qubit register and use these qubits representing the phase as controls to apply a phase rotation.

More formally, denote the value of the summation in the phase rotation as $y_r(\vec{x})$.

\begin{equation}
    \begin{split}
        y_r(\vec{x}) &= \sum_s \lambda'^{(r)}_s x_s \\
        U_A^{(r)}\ket{\vec{x}} &= e^{-i\frac{\Delta t}{2}\lambda_ry_r(\vec{x})^2}\ket{\vec{x}}
    \end{split}
\end{equation}

We begin with a register of $n$ qubits in a Fock state $\ket{\vec{x}}$ and introduce an ancilla register of $\frac{m}{2}$ and another of $m$ qubits, both initalized to zeros. We calculate an approximation $\tilde{y}_r(\vec{x})$ onto the smaller ancilla register. We use the value stored in the smaller register to compute an approximation $\tilde{y}_r(\vec{x})^2$ into the larger register. Then we use values of the $m$ ancilla qubits to rotate the phase by $e^{-i\frac{\Delta t}{2}\lambda_r\tilde{y}_r(\vec{x})^2}\ket{\vec{x}}$. Finally, we uncompute the ancilla register and remove them afterwards. These steps comprise the proposed $\tilde{U}_A^{(r)}$. If we wish to construct this circuit fault-tolerantly (i.e. with Clifford gates and T gates), the \eqref{eq: phase} step (and therefore $\tilde{U}_A^{(r)}$ as a whole) will be an approximation. 

\begin{align}
    \ket{\vec{x}} &\rightarrow \ket{\vec{x}}\ket{0^{\frac{m}{2}}}\ket{0^m} \\
    &\rightarrow \ket{\vec{x}}\ket{\tilde{y}_r(\vec{x})}\ket{0^m} \label{eq: summation}\\
    &\rightarrow \ket{\vec{x}}\ket{\tilde{y}_r(\vec{x})}\ket{\tilde{y}_r(\vec{x})^2} \label{eq: squaring} \\
    &\rightarrow e^{-i\frac{\Delta t}{2}\lambda_r\tilde{y}_r(\vec{x})^2}\ket{\vec{x}}\ket{\tilde{y}_r(\vec{x})}\ket{\tilde{y}_r(\vec{x})^2} \label{eq: phase} \\
    &\rightarrow e^{-i\frac{\Delta t}{2}\lambda_r\tilde{y}_r(\vec{x})^2}\ket{\vec{x}}\ket{0^{\frac{m}{2}}}\ket{0^m} \\
    &\rightarrow e^{-i\frac{\Delta t}{2}\lambda_r\tilde{y}_r(\vec{x})^2}\ket{\vec{x}} \\
    &\rightarrow e^{-i\frac{\Delta t}{2}\lambda_r(\sum_s \tilde{\lambda}'^{(r)}_s \ket{1}\bra{1}_s)^2}\ket{\vec{x}} \\
    &\approx \tilde{U}_A^{(r)}\ket{\vec{x}}
\end{align}

\section{Summation}

Because $\lambda'^{(r)}$ can assume any real (including irrational) values, a finite set of qubits will not be able to represent $y_r(\vec{x}) = \sum_s \lambda'^{(r)}_s x_s$ precisely. Instead, we compute an approximation $\tilde{y}_r(\vec{x})$ that can be expressed in $\frac{m}{2}$ bits. We essentially truncate (or round) each term in the sum and add them together. $m$ can be increased to enhance precision at the cost of ancilla qubits and more gates, and vice versa. In short, we'd like to use the qubits $\ket{\vec{x}}$ to transform $\ket{0^{\frac{m}{2}}}$ to $\ket{\tilde{y}_r(\vec{x})}$.

\begin{equation}
    \ket{\vec{x}}\ket{0^{\frac{m}{2}}} \rightarrow \ket{\vec{x}}\ket{\tilde{y}_r(\vec{x})} = \ket{\vec{x}}\ket{\sum_s \tilde{\lambda}'^{(r)}_s x_s}
    \label{eq: summation2}
\end{equation}

The encoding between values $z$ and qubit states must be able to handle negative numbers and must be able to hold the all possible values of $\tilde{y}_r(\vec{x})$. We define $Y_r$ as the largest number (by absolute value) that the register must hold, and we assign qubit $j$ to represent a value $2^{M_r - (\frac{m}{2} - 1) + j}$, where $M_r$ is defined below. We use a signed method, so qubit $\frac{m}{2} - 1$ represents the sign of the number. 

\begin{equation}
    Y_r = \max_{\vec{x} \in \{0, 1\}^n} |y_r(\vec{x})| = \max\left(\sum_{s : \lambda^{(r)}_s > 0} |\lambda^{(r)}_s|, \sum_{s : \lambda^{(r)}_s < 0} |\lambda^{(r)}_s|\right)
\end{equation}
\begin{equation}
    M_r = \lfloor \log_2{Y_r} \rfloor + 2
\end{equation}
\begin{equation}
    \ket{\vec{y}} \leftrightarrow \sum_{j = -\infty}^{\frac{m}{2} - 1} (-1)^{\delta_{j, \frac{m}{2} - 1}}y_j2^{M_r - (\frac{m}{2} - 1) + j}
\end{equation}

Then this register can hold all values between $-2^{M_r}$ and $2^{M_r} - 2^{M_r - (\frac{m}{2} - 1)}$ that are multiples of $2^{M_r - (\frac{m}{2} - 1)}$. By the definition of $M_r$, all possible $\tilde{y}_r(\vec{x})$ lie within this range. We can then define the bits $[\lambda^{(r)}_s]_j$ of each $\lambda^{(r)}_s$ in this signed binary form.

\begin{equation}
    \lambda^{(r)}_s = \sum_{j = -\infty}^{\frac{m}{2} - 1} (-1)^{\delta_{j, \frac{m}{2} - 1}}[\lambda^{(r)}_s]_j2^{M_r - (\frac{m}{2} - 1) + j}
\end{equation}

Since we only care about the bits for the values $2^{M_r - (\frac{m}{2} - 1)}$ to $2^{M_r}$, $\tilde{\lambda}^{(r)}_s$ is the accordingly truncated version of $\lambda^{(r)}_s$.

\begin{equation}
    \tilde{\lambda}^{(r)}_s = \sum_{j = 0}^{\frac{m}{2} - 1} (-1)^{\delta_{j, \frac{m}{2} - 1}}[\lambda^{(r)}_s]_j2^{M_r - (\frac{m}{2} - 1) + j}
\end{equation}

As shown in \ref{fig: U_A}, \eqref{eq: summation} can be achieved by a series of controlled additions. There are many ways to implement such an adder, we chose the most direct way, which simply converts a classical adder into quantum circuits. \ref{fig: add} shows how to implement a controlled addition of an arbitrary $w$ in the described signed form.

\begin{equation}
    w = \sum_{j = 0}^{\frac{m}{2} - 1} (-1)^{\delta_{j, \frac{m}{2} - 1}}[w]_j2^{M_r - (\frac{m}{2} - 1) + j}
\end{equation}

\section{Squaring}

We now have a register of $\frac{m}{2}$ qubits representing the value $\tilde{y}_r(\vec{x})$ and use this to calculate a value of $\tilde{y}_r(\vec{x})^2$ on the register of $m$ qubits.

\begin{equation}
    \ket{\vec{x}}\ket{\tilde{y}_r(\vec{x})}\ket{0^m} \rightarrow \ket{\vec{x}}\ket{\tilde{y}_r(\vec{x})}\ket{\tilde{y}_r(\vec{x})^2} \label{eq: y^2}
\end{equation}

We now design a circuit that adds the square of an arbitrary signed $\frac{m}{2}$-qubit $\ket{w}$ to an m-qubit register.

\begin{equation}
    \ket{w}\ket{z} \rightarrow \ket{w}\ket{z + w^2}
\end{equation}

Because the smallest value represented by a qubit in the $\ket{w}$ register is $2^{M_r - (\frac{m}{2} - 1)}$, the smallest value represented by a qubit in the $\ket{z}$ register will be $2^{2(M_r - (\frac{m}{2} - 1))}$. So qubit $k$ in the latter register will have value $(-1)^{\delta_{k, m - 1}}2^{2(M_r - (\frac{m}{2} - 1)) + k}$.

We can expand one of the $w$ to turn $w^2$ into a sum.

\begin{equation}
    w^2 = \sum_{j = 0}^{\frac{m}{2} - 1} (-1)^{\delta_{j, \frac{m}{2} - 1}}[w]_j2^{M_r - (\frac{m}{2} - 1) + j}w \label{eq: w^2}
\end{equation}

If one is to add $w^2$ to $z$, it's equivalent to adding each of these terms separately. The $j$th term in \eqref{eq: w^2} is only nonzero if $[w]_j = 1$, so it's equivalent to a having a control on the $j$th qubit in $\ket{w}$. Adding $2^{M_r - (\frac{m}{2} - 1) + j}w$ is equivalent to adding $w$ but shifted up $j$ qubits. Note that because $[w]_{\frac{m}{2} - 1}$ is a sign bit, it must continue to be added to all bits in $\ket{z}$ until the end, accordingly with classical signed addition. \ref{fig: squaring} shows a quantum circuit that adds $[w]_j2^{M_r - (\frac{m}{2} - 1) + j}w$.
We can handle the $(-1)^{\delta_{j, \frac{m}{2} - 1}}$, which flips the sign for $j = \frac{m}{2} - 1$, by performing a controlled subtraction instead of an addition. A controlled subtraction is equivalent to the Hermitian (in this case, a reverse circuit) of the controlled addition.

Performing the circuit described in \ref{eq: w^2} using $w = \tilde{y}_r(\vec{x})$ will successfully accomplish \ref{eq: y^2}.

\section{Phase Rotation}

We now have a register of $m$ qubits in which the $k$th qubit has state $\ket{[\tilde{y}_r(\vec{x})^2]_k}$.

\begin{equation}
    \tilde{y}_r(\vec{x})^2 = \sum_k (-1)^{\delta_{k, m - 1}}[\tilde{y}_r(\vec{x})^2]_k2^{2(M_r - (\frac{m}{2} - 1)) + k}
\end{equation}

As described in \eqref{eq: phase}, we'd like to apply a phase of $e^{-i\frac{\Delta t}{2}\lambda_r\tilde{y}_r(\vec{x})^2}$. We can rewrite this phase in the form $e^{i\sum_k [\tilde{y}_r(\vec{x})^2]_k\varphi_k}$.


\begin{equation}
    \begin{split}
        -\frac{\Delta t}{2}\lambda_r\tilde{y}_r(\vec{x})^2 &= \frac{\Delta t}{2}\lambda_r\sum_k (-1)^{\delta_{k, m - 1}}[\tilde{y}_r(\vec{x})^2]_k2^{2(M_r - (\frac{m}{2} - 1)) + k} \\
        &= \sum_k [\tilde{y}_r(\vec{x})^2]_k\varphi_k
    \end{split}
\end{equation}

\begin{equation}
    \varphi_k = -(-1)^{\delta_{k, m - 1}}\frac{\Delta t}{2}\lambda_r2^{2(M_r - (\frac{m}{2} - 1)) + k}
\end{equation}

\begin{equation}
    \begin{split}
        -\frac{\Delta t}{2}\lambda_r\tilde{y}_r(\vec{x})^2 &= \frac{\Delta t}{2}\lambda_r\sum_k (-1)^{\delta_{k, m - 1}}[\tilde{y}_r(\vec{x})^2]_k2^{2(M_r - (\frac{m}{2} - 1)) + k} \\
        &= \sum_k [\tilde{y}_r(\vec{x})^2]_k\varphi_k
    \end{split}
\end{equation}

We can then decompose the phase operation into several $R_z$ gates. These gates are shown in \ref{fig: U_A}.

\begin{equation}
    \begin{split}
        \ket{\vec{x}}\ket{\tilde{y}_r(\vec{x})}\ket{\tilde{y}_r(\vec{x})^2} &\rightarrow e^{i\frac{\Delta t}{2}\lambda_r\tilde{y}_r(\vec{x})^2}\ket{\vec{x}}\ket{\tilde{y}_r(\vec{x})}\ket{\tilde{y}_r(\vec{x})^2} \\
        &= \ket{\vec{x}}\ket{\tilde{y}_r(\vec{x})}e^{i\sum_k [\tilde{y}_r(\vec{x})^2]_k\varphi_k}\ket{\tilde{y}_r(\vec{x})^2} \\
        &= \ket{\vec{x}}\ket{\tilde{y}_r(\vec{x})}\prod_k e^{i[\tilde{y}_r(\vec{x})^2]_k\varphi_k}\ket{\tilde{y}_r(\vec{x})^2} \\
        &= \ket{\vec{x}}\ket{\tilde{y}_r(\vec{x})}\prod_k (\ket{0}\bra{0} + e^{i\varphi_k}\ket{1}\bra{1})_k \ket{\tilde{y}_r(\vec{x})^2} \\
        &= \ket{\vec{x}}\ket{\tilde{y}_r(\vec{x})}e^{i\sum_k \varphi_k}\prod_k R_z(\varphi_k)_k \ket{\tilde{y}_r(\vec{x})^2}
    \end{split}
\end{equation}

\begin{equation}
    R_z(\varphi) = \begin{bmatrix}
        e^{-i\frac{\varphi}{2}} & 0 \\ 0 & e^{i\frac{\varphi}{2}}
    \end{bmatrix} = e^{-i\frac{\varphi}{2}}\begin{bmatrix}
        1 & 0 \\ 0 & e^{i\varphi}
    \end{bmatrix} = e^{-i\frac{\varphi}{2}}(\ket{0}\bra{0} + e^{i\varphi}\ket{1}\bra{1})
\end{equation}

We observe that factoring the phase into $R_z$ rotations results in a global phase factor $e^{i\sum_k \varphi_k}$. However, such a phase can be ignored as long as it is independent of $\vec{x}$ (which it is).

Because the $R_z$ gate is not a Clifford gate, it cannot be directly implemented in a fault-tolerant way. Instead, it must be approximated using Clifford and $T$ gates. The number of such gates scales with $O(\log_2(\frac{1}{\epsilon_z}))$, where $\epsilon_z$ is the desired precision of the $R_z$ operator. An implementation by \cite{Rz} achieves a T-count of $10 + 4\log_2(\frac{1}{\epsilon_z})$. 

Once the phase has been applied, it is necessary to uncompute the values $\tilde{y}_r(\vec{x}), \tilde{y}_r(\vec{x})^2$ computed in the ancilla registers and reset the registers to zeros. One can simply do this by applying all the previous gates (in the summation and squaring) in reverse order. Then the empty registers can be safely removed and $\tilde{U}_A^{(r)}$ has successfully been applied.

\section{Error Analysis}

The size of the ancilla registers is determined by $m$ and affects the precision of the applied phase. A larger $m$ means more ancilla registers and a more precise phase, but increases the gate cost. If we want to guarantee an error below $\epsilon$ accordingly with \eqref{eq: error}, $m$ must be sufficiently large. We now calculate the relation between $\epsilon$ and $m$. This is to say that we upper bound the error $||U_A^{(r)} - \tilde{U}_A^{(r)}||$ in terms of $m$.

The error originates from both the truncation of $\lambda^{(r)}_s$ into $\tilde{\lambda}^{(r)}_s$ and the inherent error in applying non-Clifford ($R_z$) gates. The error then propagates into $\tilde{U}_A^{(r)}$. So we begin by bounding the error in $\tilde{\lambda}^{(r)}_s$.

\begin{equation}
    \begin{split}
        |\lambda^{(r)}_s - \tilde{\lambda}^{(r)}_s| = \sum_{j = -\infty}^{-1} [\lambda^{(r)}_s]_j2^{M_r - (\frac{m}{2} - 1) + j} \leq \sum_{j = -\infty}^{-1} 2^{M_r - (\frac{m}{2} - 1) + j} \leq 2^{M_r - (\frac{m}{2} - 1)} \leq \frac{4Y_r}{2^{\frac{m}{2} - 1}}
    \end{split}
\end{equation}

We propagate this error to $\tilde{y}(\vec{x})$.

\begin{equation}
    \begin{split}
        |y_r(\vec{x}) - \tilde{y}(\vec{x})| = |\sum_s (\lambda^{(r)}_s - \tilde{\lambda}^{(r)}_s)x_s| \leq n|\lambda^{(r)}_s - \tilde{\lambda}^{(r)}_s| \leq \frac{Y_r}{2^{\frac{m}{2} - 3}}
    \end{split}
\end{equation}

We propagate this error to $\tilde{y}(\vec{x})^2$.

\begin{equation}
    \begin{split}
        |y_r(\vec{x})^2 - \tilde{y}(\vec{x})^2| &= |2y_r(\vec{x})(y_r(\vec{x}) - \tilde{y}(\vec{x})) - (y_r(\vec{x}) - \tilde{y}(\vec{x}))^2| \\
        &\leq \max\left(2|y_r(\vec{x})|n\frac{Y_r}{2^{\frac{m}{2} - 3}}, \left(n\frac{Y_r}{2^{\frac{m}{2} - 3}}\right)^2\right)
    \end{split}
\end{equation}

Recall that there is some error generated from the $m$ $R_z$ gates in $\tilde{U}_A^{(r)}$. Each gate generates error $\epsilon_z$, which is variable depending on how many Clifford + $T$ gates we use to implement it. Since the operator norm is a norm, the total error is sub-additive.

\begin{equation}
    \begin{split}
        ||e^{-\frac{i\Delta t}{2}\lambda_r\left(\sum_s \tilde{\lambda}'^{(r)}_s \ket{1}\bra{1}_s\right)^2} - \tilde{U}_A^{(r)}|| &\leq m\epsilon
    \end{split}
\end{equation}

We can propagate both errors into the overall error $||U_A^{(r)} - \tilde{U}_A^{(r)}||$.

\begin{equation}
    \begin{split}
        ||U_A^{(r)} - \tilde{U}_A^{(r)}|| &\leq ||U_A^{(r)} - e^{-\frac{i\Delta t}{2}\lambda_r\left(\sum_s \tilde{\lambda}'^{(r)}_s \ket{1}\bra{1}_s\right)^2}|| + ||e^{-\frac{i\Delta t}{2}\lambda_r\left(\sum_s \tilde{\lambda}'^{(r)}_s \ket{1}\bra{1}_s\right)^2} - \tilde{U}_A^{(r)}|| \\
        &\leq \max_{\ket{\psi} : ||\ket{\psi}|| = 1} ||(U_A^{(r)} - e^{-\frac{i\Delta t}{2}\lambda_r\left(\sum_s \tilde{\lambda}'^{(r)}_s \ket{1}\bra{1}_s\right)^2})\ket{\psi}|| + m\epsilon_z \\
        &= \max_{\vec{x} \in \{0, 1\}^n} ||(e^{-i\frac{\Delta t}{2}\lambda_ry_r(\vec{x})^2} - e^{-i\frac{\Delta t}{2}\lambda_r\tilde{y}_r(\vec{x})^2})\ket{\vec{x}}|| + m\epsilon_z \\
        &= \max_{\vec{x} \in \{0, 1\}^n} ||(e^{-i\frac{\Delta t}{2}|\lambda_r|(y_r(\vec{x})^2 - \tilde{y}_r(\vec{x})^2)} - 1)\ket{\vec{x}}|| + m\epsilon_z \\
        &\leq \max_{\vec{x} \in \{0, 1\}^n} \frac{\Delta t}{2}|\lambda_r||y_r(\vec{x})^2 - \tilde{y}_r(\vec{x})^2| + m\epsilon_z \\
        &\leq \frac{\Delta t}{2}|\lambda_r|\max_{\vec{x} \in \{0, 1\}^n} \max\left(2|y_r(\vec{x})|n\frac{Y_r}{2^{\frac{m}{2} - 3}}, \left(n\frac{Y_r}{2^{\frac{m}{2} - 3}}\right)^2\right) + m\epsilon_z \\
        &= n\frac{|\lambda_r| Y_r^2\Delta t}{2^{\frac{m}{2} - 4}}\max\left(1, \frac{n}{2^{\frac{m}{2} - 2}}\right) + m\epsilon_z
    \end{split}
\end{equation}

We want $m$ to be large enough and $\epsilon_z$ small enough that this quantity is at most $\epsilon$. To make the calculations simpler, we can restrict both terms to at most $\frac{\epsilon}{2}$.

\begin{equation}
    \begin{split}
        \frac{\epsilon}{2} &\geq n\frac{|\lambda_r| Y_r^2\Delta t}{2^{\frac{m}{2} - 4}}\max\left(1, \frac{n}{2^{\frac{m}{2} - 2}}\right) \\
        \implies m_{min} &\geq \max(2\log_2\left(n\frac{|\lambda_r|Y_r^2\Delta t}{\epsilon}\right) + 4, \log_2\left(n^2\frac{|\lambda_r|Y_r^2\Delta t}{\epsilon}\right) + 6) \\
        &= 2\log_2(n) + 2\log_2\left(\frac{|\lambda_r|Y_r^2\Delta t}{\epsilon}\right) + 4 \label{eq: m_min}
    \end{split}
\end{equation}

We choose the first input of the $\max$. Both options are asymptotically the same, so we choose the one with the larger constant factor to establish an upper bound on the threshold. If it turns out that $\log_2\left(n^2\frac{|\lambda_r|Y_r^2\Delta t}{\epsilon}\right) < 2$, then $m_{min}$ won't be much larger than $2\log_2(n)$ anyway.

Clearly the minimum value of $m$ is asymptotically logarithmic in $n$, as long as $|\lambda_r|$ and $Y_r$ are not exponential in $n$ (in reality they are sublinear). Referring back to \eqref{eq: toffolis}, the total asymptotic gate cost of $\tilde{U}_A^{(r)}$ is therefore $O(mn + m^2) = O(n\log{n} + (\log{n})^2) = O(n\log{n})$.

$m$ is also logarithmic in $\Delta t$ and in $\frac{1}{\epsilon}$.

Meanwhile, the restriction on $m\epsilon_z$ allows for lower bound on $\epsilon_z$.

\begin{equation}
    \begin{split}
        \frac{\epsilon}{2} &\geq m\epsilon_z \\
        \implies \epsilon_z &\geq \frac{\epsilon}{2m} \label{eq: e_z}
    \end{split}
\end{equation}

\section{Complexity Analysis}

We would like to establish an upper bound on the cost of $\tilde{U}_A^{(r)}$. In implementing fault-tolerant quantum circuits, the T-count is the usual cost metric, since $T$-state distillation is usually the bottleneck.

The controlled constant addition in \ref{fig: add} requires $\frac{m}{2} - 1$ ancilla qubits (in addition to the target register) and its gate count depends on the values of $[w]_j$. At maximum, it requires $1.5m - 5$ Toffolis and $2.5m - 7$ CNOTs.

Next, we wish to find the cost of the squaring circuit in \ref{fig: squaring}. Observe that for each $\ket{z}_{j + 2}, ..., \ket{z}_{m - 1}$, there are $8$ Toffolis \footnote{When iterating through each of the qubits in $\ket{w}$, inevitably one or more of these qubits will be $\ket{w}_j$. One of the gates in an iteration is a Toffoli controlled by $\ket{w}_j$ and the iterated qubit, which in this case is itself. Then that Toffoli will actually be a CNOT with a lower cost. We ignore this edge case because we only need an upper bound}. There are $4$ additional Toffolis ($2$ for the highest bit and $2$ at the beginning and end). This is a total of $8(m - j - 2) + 4$ Toffolis in \ref{fig: squaring}.

Since the squaring protocol performs \ref{fig: squaring} for each $j \in [0, \frac{m}{2})$, we can calculate the total number of Toffolis in the squaring protocol.

\begin{equation}
    \begin{split}
        \sum_{j = 0}^{\frac{m}{2} - 1} (8(m - j - 2) + 4) &= 8m^2 - 8\frac{\frac{m}{2}(\frac{m}{2} - 1)}{2} - 8m + 4m \\
        &= 7m^2 - 2m
    \end{split}
\end{equation}

In our implementation of $\tilde{U}_A^{(r)}$, there are $2n$ controlled constant additions ($n$ to compute and $n$ to uncompute) and $2$ squaring protocols (once to compute and uncompute). The phase rotations only contribute $n$ single-qubit gates, which are negligible. We can calculate the total number of Toffolis in $\tilde{U}_A^{(r)}$.

\begin{equation}
    \begin{split}
        \tilde{N}_{CCNOT} &= 2n(1.5m - 5) + 2(7m^2 - 2m) \\
        &= 3mn - 10n + 14m^2 - 4m \\
        &= O(mn + m^2) \label{eq: toffolis}
    \end{split}
\end{equation}

Given $\epsilon_z$, each $R_z$ gate requires $10 + 4\log_2(\frac{1}{\epsilon_z})$ T-gates using the implementation in \cite{Rz}. There are $m$ $R_z$ gates in $\tilde{U}_A^{(r)}$. We can use the minimum $\epsilon_z$ calculated in \eqref{eq: e_z} to upper-bound this number of $T$s in terms of $m$ and $\epsilon$.

\begin{equation}
    \begin{split}
        \tilde{N}_{T; Rz} &= m(10 + 4\log_2(\frac{1}{\epsilon_z})) \\
        &= 10m + 4m\log_2(\frac{2m}{\epsilon})
    \end{split}
\end{equation}

A Toffoli gate can be constructed from $2$ Hadamard gates, $6$ CNOT gates, and $7$ T-gates. We can then calculate the total $T$-count of $\tilde{U}_A^{(r)}$.

\begin{equation}
    \begin{split}
        \tilde{N}_{T} &= 7\tilde{N}_{CCNOT} + \tilde{N}_{T; Rz} \\
        &= 21mn - 70n + 98m^2 - 28m + 10m + 4m\log_2(\frac{2m}{\epsilon}) \\
        &= 21mn - 70n + 98m^2 - 18m + 4m\log_2(\frac{2m}{\epsilon}) \\
        &= O(mn + m^2 + m\log_2(\frac{1}{\epsilon})) \label{eq: Ts_mneps}
    \end{split}
\end{equation}

We can substitute the asymptotic threshold $m = O(\log_2(\frac{n}{\epsilon}))$ from \eqref{eq: m_min} to obtain an asymptotic $\tilde{N}_{T}$ in terms of $n$ and $\frac{1}{\epsilon}$.

\begin{equation}
    \begin{split}
        \tilde{N}_{T} &= O(\log_2(\frac{n}{\epsilon})n + (\log_2(\frac{n}{\epsilon}))^2 + \log_2(\frac{n}{\epsilon})\log_2(\frac{1}{\epsilon})) \\
        &= O(n\log_2(\frac{n}{\epsilon}) + \log_2(\frac{1}{\epsilon})^2) \label{eq: Ts_neps}
    \end{split}
\end{equation}

\section{Numerics}

The gate cost of this $\tilde{U}_A^{(r)}$ is asympotically lower in $n$ than the $O(n^2\log_2(\frac{n}{\epsilon}))$ cost of the expansion method in \eqref{eq: expansionTs}, which is a significant advantage. It's useful to get a (very rough) numerical estimate of the gate counts to understand the scale ($n$) at which the advantage appears.

The value of $\Delta t$ depends on the particular Trotter-like algorithm used. A very loose upper bound for $\Delta t$ is $t$ itself. \cite{Gate_Count} uses $t = 6000 \frac{1}{E_h}$ and $\epsilon = 10^{-6}$. We decomposed Hamiltonians of hydrogen chain systems for various $n$ ($n$ is the number of $H$s and the number of orbitals) to obtain values of $|\lambda_r|$ and $Y_r$. It turns out for these systems that $|\lambda_r|Y_r^2 \approx n\log_2{n} E_h$.

\begin{equation}
    \begin{split}
        m_{min} &\leq 2\log_2(n) + 2\log_2\left(\frac{|\lambda_r|Y_r^2 t}{\epsilon}\right) + 3 \\
        &\leq 2\log_2(n) + 2\log_2\left(\frac{n\log_2{n}\times 6000}{10^{-6}}\right) + 3 \\
        &\approx 4\log_2(n) + 2\log_2(\log_2(n)) + 68
    \end{split}
\end{equation}

In practice, $\Delta << t$, so $t$ is not a useful order of magnitude for $\Delta t$. \cite{Gate_Count} also mentions a value $\Delta t = 0.01 \frac{1}{E_h}$ which may give a more accurate sense of the scale of $\Delta t$.

\begin{equation}
    \begin{split}
        m_{min} \leq 2\log_2(n) + 2\log_2\left(\frac{n\log_2{n}\times 0.01}{10^{-6}}\right) + 3 \approx 4\log_2(n) + 2\log_2(\log_2(n)) + 17
    \end{split}
\end{equation}

In non-fault-tolerant computing, quantum gate cost is often measured by the number of two-qubit gates (in our case, CNOTs). So we can substitute this function $m(n)$ back into \eqref{eq: cnots} and plot $\tilde{N}_{CNOT}$ as a function of $n$. We can then compare $\tilde{N}_{CNOT}$ with $N_{CNOT} = 2{n \choose 2}$, the number of CNOTs necessary to implement \eqref{eq: expansion} (a controlled Z-rotation can be done with $2$ CNOTs and two $P$ gates) \cite{gates}. It turns out that $\tilde{N}_{CNOT} = N_{CNOT}$ when $n = 3023.3$, above which $\tilde{N}_{CNOT} < N_{CNOT}$.

\textcolor{red}{I will add this plot later}

In fault-tolerant computing, the bottleneck is the number of T-gates. In this framework, only Clifford gates and T gates are allowed, and gates not in this category, such as $P$ gates, must be approximated by decomposing it into Clifford and T gates. \textcolor{red}{I need to ask Aram how exactly this happens and how I should calculate this. Because there are P gates in both methods. Also there was that thing about the log(1/eps) error which I didn't exactly catch.}


%When is O(n log n) really better than n^2/2?

%Mention that if it's really diagonal, then we can just qdrift the rotations.

\section{Discussion}

The asymptotic advantage of the coherent method ($O(n^3\log_2{n})$) over the naive method ($O(n^4)$) only results in an overall asymptotic advantage if $U(R^{(r)})$ can also be implemented in with sub-quadratic gate complexity. \cite{FSN} decomposed $U(R^{(r)})$ into a series of at most ${n \choose 2}$ two-orbital basis rotations, each implementable in a constant number of quantum gates. However, for certain types of Hamiltonians, the necessary number of such rotations is often much smaller.

The minimum number of rotation is $0$, which occurs when $R^{(r)} = I$; that is, when $Q^{(r)}$ is already diagonal. However, if this is the case for all $r \in [0, n^2)$ in $\hat{H}_{2e}$, then all of the terms in $\hat{H}_{2e}$ can be combined into $n^2$ terms as shown in \eqref{eq: collapse}, resulting in a $O(n^2)$ complexity for $\hat{H}_{2e}$, in which case the coherent method would not be useful.

\begin{equation}
    \begin{split}
        \hat{H}_{2e} &= \frac{1}{2}\sum_r\lambda_r\left(\sum_{i,j} Q^{(r)}_{i, j}a^\dag_ia_j\right)^2 \\
        &= \frac{1}{2}\sum_r\lambda_r(\sum_{s} \lambda'^{(r)}_sn_s)^2 \\
        &= \frac{1}{2}\sum_{s, s'} n_sn_{s'}\sum_r\lambda_r\lambda'^{(r)}_s\lambda'^{(r)}_{s'}
    \end{split}
    \label{eq: collapse}
\end{equation}

In fact, more generally, if $R^{(r)}$ is invariant across $r$, all of the different $\tilde{n}^{(r)}_s$ are in the same basis across $r$. Then the basis rotations $U(R^{(r)})$ and $U(R^{(r)})^\dag$ can be performed at the beginning and end without the need to switch bases between $r$. Then $\hat{H}_{2e}$ combines into $O(n^2)$ terms in \eqref{eq: collapse2}, just like in \eqref{eq: collapse}. Since $U(R^{(r)})$ uses $O(n^2)$ but is only performed twice, the total complexity is $O(n^2)$ for $\hat{H}_{2e}$, and the coherent would not be useful in this case either.

\begin{equation}
    \begin{split}
        \hat{H}_{2e} &= \frac{1}{2}\sum_r\lambda_r\left(\sum_s \lambda'^{(r)}_s \tilde{n}_s\right)^2 \\
        &= \frac{1}{2}\sum_{s, s'} \tilde{n}_s\tilde{n}_{s'}\sum_r\lambda_r\lambda'^{(r)}_s\lambda'^{(r)}_{s'}
    \end{split}
    \label{eq: collapse2}
\end{equation}

Moreover, if all the $Q^{(r)}$ are diagonally dominated (the magnitude of the terms on its diagonal dominates over the non-diagonal terms) or if they have very few ($O(\sqrt{n})$) nonzero off-diagonal elements, then the expansion of $\hat{H}_{2e}$ also contains a reduced number of terms that make the coherent method unnecessary.

For the coherent method to be useful, all of the $U(R^{(r)})$ should decompose to $o(n^2)$ rotations, but $Q^{(r)}$ should have $\omega(\sqrt{n})$ non-zero terms (not a tight bound). This opens an area for future work to address: identifying useful Hamiltonians that satisfy these conditions.

In the next section, we will focus on one family of Hamiltonians that satisfy these conditions.

%We need it to be O(n) rotations but O(n^2) nonzeros in R.

%Example? k-local.


%%%%%%%%%%%%%%%% end table %%%%%%%%%%%%%%%%%%% 

